# to build rsa unit tests compile with TESTS=y.
#
# - set u64 type definition by compiling with:
#   U64=UCHAR    for unsigned char
#   U64=USHORT   for unsigned short
#   U64=ULONG    for unsigned long
#   U64=ULLONG   for unsigned long long (default)
# 
# - to enable function timing feature compile with TIME_FUNCTIONS=y.
#
# - RSA encryption level can be set if U64 is set to ULLONG. This is done as
#   follows: 
#   ENC_LEVEL=128
#   ENC_LEVEL=256
#   ENC_LEVEL=512
#   ENC_LEVEL=1024 (default)
#   for a non ULLONG value of U64 ENC_LEVEL=1024.
#
# to build signed rsa encoder and decoders compile with SIG='name'.
# a public key created by the rsa_enc application will contain a field with 
# 'name' signed by the private key and the private key created by the rsa_enc
# application will contain a field with 'name' encrypted by the public key.
# this is used to force rsa_enc and rsa_dec pairs to only use keys generated by
# by rsa-enc

CC=gcc
TARGET_OBJS=rsa_num.o
CONFFILE=rsa.mk

-include $(CONFFILE)

CFLAGS=-Wall -Werror 

# Takuji Nishimura and Makoto Matsumoto's 64-bit version of Mersenne Twister 
# pseudorandom number generator
ifeq ($(MERSENNE_TWISTER),)
  MERSENNE_TWISTER=y
endif
ifeq ($(MERSENNE_TWISTER),y)
  TARGET_OBJS+=mt19937_64.o
  CFLAGS+=-DMERSENNE_TWISTER
endif

# set encryption level
ENC_LEVEL_VALUES=128 256 512 1024
ifeq ($(ENC_LEVEL),)
  ENC_LEVEL=1024
else
  ifeq ($(filter $(ENC_LEVEL_VALUES),$(ENC_LEVEL)),)
    $(error ENC_LEVEL possible values = {$(ENC_LEVEL_VALUES)}) # error!
  endif
endif

CFLAGS+=-DEL=$(ENC_LEVEL)

# set unit test configuration
ifeq ($(TESTS),y)

  # enable/disable function timing
  ifeq ($(TIME_FUNCTIONS),y)
    CFLAGS+=-DTIME_FUNCTIONS
  endif
  ifeq ($(PROFILING),y)
    CFLAGS+=-pg
  endif

  # u64 type definition
  U64_VALUES=UCHAR USHORT ULONG ULLONG
  ifeq ($(U64),)
    U64=ULLONG
  else
    ifeq ($(filter $(U64_VALUES),$(U64)),)
      $(error U64 possible values = {$(U64_VALUES)}) # error!
    endif
  endif

  # assert U64/ENC_LEVEL compatability
  ifneq ($(ENC_LEVEL),1024)
    ifneq ($(U64),ULLONG)
      $(error (for ENC_LEVEL=$(ENC_LEVEL) U64 must be ULLONG)) # error!
    endif
  endif

  TARGET=test_rsa
  TARGET_OBJS+=rsa_test.o
  CFLAGS+=-g -DTESTS -D$(U64)
else # create rsa applications
  ifeq ($(SIG),) # master encrypter/decrypter
%.o: %.c rsa.h
	$(CC) -o $@ $(CFLAGS) -c $<

rsa.o: $(TARGET_OBJS) $(TAILOR_OBJS)
	$(CC) -o $@ $^

    TARGET=rsa
  else # create separate encoder/decoder
rsa_enc.o: %.c rsa.h
	$(CC) -o $@ $(CFLAGS) -DRSA_ENC -c $<

rsa_dec.o: %.c rsa.h
	$(CC) -o $@ $(CFLAGS) -DRSA_DEC -c $<

rsa_%: $(TARGET_OBJS) $(TAILOR_OBJS:.o=%.o)
	$(CC) -o $@ $^

    TARGET=rsa_enc rsa_dec
    CFLAGS+=-DSIG=\"$(SIG)\" # ENC/DEC
  endif

  TAILOR_OBJS=main.o rsa_key.o rsa_io.o
  CFLAGS+=-DULLONG
endif

.PHONY: all clean cleanapps cleantags cleanconf cleanall config

%.o: %.c rsa.h
	$(CC) -o $@ $(CFLAGS) -c $<

all: $(TARGET)

$(TARGET): $(TARGET_OBJS)
	$(CC) $(CFLAGS) -o $@ $^ -lm

config:
	@echo "doing make config"
	set -e; \
	rm -f $(CONFFILE); \
	echo "$(strip $(MAKEFLAGS))" | sed -e 's/ /\r\n/g' > $(CONFFILE);

clean:
	rm -f *.o gmon.out

cleanapps:
	file `ls` | grep executable | awk -F: '{ print $$1 }' | xargs rm -f

cleantags:
	rm -f tags

cleanconf:
	rm -f $(CONFFILE)

cleanall: clean cleanapps cleantags cleanconf
